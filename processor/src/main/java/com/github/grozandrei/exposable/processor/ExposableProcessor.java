/**
 *
 */
package com.github.grozandrei.exposable.processor;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedOptions;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic.Kind;

import com.github.grozandrei.exposable.annotation.Exposable;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;

/**
 * Exposable annotation processor. This processor generates description for all fields from classes annotated with <b>@Exposable</b> annotation
 *
 * @author Andrei Groza
 *
 */
@SupportedAnnotationTypes("com.github.grozandrei.exposable.annotation.Exposable")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
@SupportedOptions({ "debug" })
public class ExposableProcessor extends AbstractProcessor {

	/**
	 * Generated field description prefix
	 */
	private static final String	FIELD_PREFIX			= "FIELD_";

	/**
	 * Generated field description javadoc
	 */
	private static final String	FIELD_JAVADOC			= "Name of field";

	/**
	 * Generated files javadoc
	 */
	private static final String	GENERATED_FILES_JAVADOC	= "This is a class generated by exposable annotation processor. Do NOT edit this class by hand!";

	@Override
	public boolean process(
			final Set<? extends TypeElement> annotations,
			final RoundEnvironment roundEnv) {
		final Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(Exposable.class);

		if (!elements.isEmpty()) {
			this.processingEnv.getMessager().printMessage(Kind.NOTE, "Start generating fields descriptors for exposable classes..");

			for (final Element elem : elements) {
				final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(elem.getSimpleName() + "_").addJavadoc("$S" + System.lineSeparator(),
						GENERATED_FILES_JAVADOC);
				final Exposable exposableAnnotation = elem.getAnnotation(Exposable.class);
				final List<Modifier> excludeModifiers = Arrays.asList(exposableAnnotation.exclude());
				for (final Element subElement : elem.getEnclosedElements()) {
					if (subElement.getKind() == ElementKind.FIELD) {
						if (subElement.getModifiers().stream().anyMatch(modifier -> excludeModifiers.contains(modifier))) {
							this.processingEnv.getMessager().printMessage(Kind.NOTE,
									"Skipping generation of metadata for field " + subElement.getSimpleName().toString());
						} else {
							final FieldSpec fieldSpec = FieldSpec
									.builder(String.class, buildFieldDescriptionName(subElement.getSimpleName().toString()), Modifier.PUBLIC, Modifier.STATIC,
											Modifier.FINAL)
									.initializer("$S", subElement.getSimpleName().toString())
									.addJavadoc("$S" + System.lineSeparator(), FIELD_JAVADOC + " <b>" + subElement.getSimpleName().toString() + "</b>").build();
							classBuilder.addField(fieldSpec);
						}
					}
				}
				final TypeSpec typespec = classBuilder.addModifiers(Modifier.PUBLIC, Modifier.FINAL).build();
				final JavaFile javaFile = JavaFile.builder(elem.getEnclosingElement().toString(), typespec).build();

				this.processingEnv.getMessager().printMessage(Kind.NOTE,
						"Generating metadata exposable class: " + javaFile.packageName + "." + elem.getSimpleName() + "_");
				try {
					javaFile.writeTo(this.processingEnv.getFiler());
				} catch (final IOException e) {
					this.processingEnv.getMessager().printMessage(Kind.ERROR, "Cannot write generated class file " + e.getLocalizedMessage());
				}
			}

			this.processingEnv.getMessager().printMessage(Kind.NOTE, "Finish generating fields descriptors for exposable classes.");
		}

		return true;
	}

	private String buildFieldDescriptionName(
			final String fieldName) {
		final String regex = "([a-z])([A-Z])";
		final String replacement = "$1_$2";
		return FIELD_PREFIX + fieldName.replaceAll(regex, replacement).toUpperCase();
	}

}
