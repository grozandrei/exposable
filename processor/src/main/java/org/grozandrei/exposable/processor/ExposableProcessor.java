/**
 *
 */
package org.grozandrei.exposable.processor;

import java.io.IOException;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedOptions;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic.Kind;

import org.grozandrei.exposable.annotation.Exposable;

import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;

/**
 * Exposable annotation processor. This processor generates description for all fields from classes annotated with <b>@Exposable</b> annotation
 *
 * @author Andrei Groza
 *
 */
@SupportedAnnotationTypes("org.grozandrei.exposable.annotation.Exposable")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
@SupportedOptions({ "debug" })
public class ExposableProcessor extends AbstractProcessor {

	/**
	 * Generated field description prefix
	 */
	private static final String	FIELD_PREFIX				= "FIELD_";

	/**
	 * Generated field description javadoc
	 */
	private static final String	FIELD_JAVADOC				= "Name of field";

	/**
	 * Generated files destination
	 */
	private static final String	GENERATED_FILES_DESTINATION	= "target/generated-sources/annotations";

	/**
	 * Generated files javadoc
	 */
	private static final String	GENERATED_FILES_JAVADOC		= "This is a class generated by exposable annotation processor. Do edit this class by hand!";

	@Override
	public boolean process(
			final Set<? extends TypeElement> annotations,
			final RoundEnvironment roundEnv) {
		processingEnv.getMessager().printMessage(Kind.NOTE, "Start generating exposable classes..");

		for (final Element elem : roundEnv.getElementsAnnotatedWith(Exposable.class)) {
			final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(elem.getSimpleName() + "_").addJavadoc("$S" + System.lineSeparator(),
					GENERATED_FILES_JAVADOC);
			for (final Element subElement : elem.getEnclosedElements()) {
				if (subElement.getKind() == ElementKind.FIELD) {
					final FieldSpec fieldSpec = FieldSpec
							.builder(String.class, buildFieldDescriptionName(subElement.getSimpleName().toString()), Modifier.PUBLIC, Modifier.STATIC,
									Modifier.FINAL)
							.initializer("$S", subElement.getSimpleName().toString())
							.addJavadoc("$S" + System.lineSeparator(), FIELD_JAVADOC + " <b>" + subElement.getSimpleName().toString() + "</b>").build();
					classBuilder.addField(fieldSpec);
				}
			}
			final TypeSpec typespec = classBuilder.addModifiers(Modifier.PUBLIC, Modifier.FINAL).build();
			final JavaFile javaFile = JavaFile.builder(elem.getEnclosingElement().toString(), typespec).build();

			processingEnv.getMessager().printMessage(Kind.NOTE, "Generating exposable class: " + javaFile.packageName + "." + elem.getSimpleName() + "_");
			try {
				// javaFile.writeTo(new File(GENERATED_FILES_DESTINATION));
				javaFile.writeTo(processingEnv.getFiler());
			} catch (final IOException e) {
				processingEnv.getMessager().printMessage(Kind.ERROR, "Cannot write generated class file " + e.getLocalizedMessage());
			}
		}

		processingEnv.getMessager().printMessage(Kind.NOTE, "End generating exposable classes.");

		return true;
	}

	private String buildFieldDescriptionName(
			final String fieldName) {
		final String regex = "([a-z])([A-Z])";
		final String replacement = "$1_$2";
		return FIELD_PREFIX + fieldName.replaceAll(regex, replacement).toUpperCase();
	}

}
